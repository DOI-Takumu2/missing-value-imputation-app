# -*- coding: utf-8 -*-
"""kessonntisyori.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12hJei74sXfJAu2UBFWZ5GBgSZ2j0_LQx
"""

!pip install scikit-learn

import sklearn
print(sklearn.__version__)

from sklearn.experimental import enable_iterative_imputer  # これが必要
from sklearn.impute import IterativeImputer

!pip install --upgrade scikit-learn

# 必要なライブラリのインポート
from google.colab import files
import pandas as pd
import io

# 1. ファイルアップロード
print("処理したいCSVファイルをアップロードしてください")
uploaded = files.upload()  # ファイルをアップロード

# 2. アップロードされたファイルの読み込み
for filename in uploaded.keys():
    print(f"{filename} を読み込み中...")
    df = pd.read_csv(io.BytesIO(uploaded[filename]))

print("アップロードされたデータのプレビュー:")
print(df.head())

# 3. 欠損値の補完方法の選択
print("\n補完方法を選択してください:")
print("1: 段階的な平均値")
print("2: ベイズ統計")
print("3: 回帰分析")

method = int(input("番号を入力してください（1〜3）: "))

# 4. 欠損値補完の処理
if method == 1:
    # 段階的な平均値
    def stepwise_fill(df):
        df = df.copy()
        for col in df.columns:
            for i in range(len(df[col])):
                if pd.isnull(df[col][i]):  # 欠損値の場合
                    prev_val = None
                    next_val = None
                    # 前後の値を探す
                    for j in range(i - 1, -1, -1):
                        if not pd.isnull(df[col][j]):
                            prev_val = df[col][j]
                            break
                    for j in range(i + 1, len(df[col])):
                        if not pd.isnull(df[col][j]):
                            next_val = df[col][j]
                            break
                    if prev_val is not None and next_val is not None:
                        gap = j - i + 1  # 次の値までのステップ数
                        step_avg = (next_val - prev_val) / gap
                        df[col][i] = prev_val + step_avg
        return df

    filled_df = stepwise_fill(df)

elif method == 2:
    # ベイズ統計（簡易バージョン）
    from sklearn.impute import IterativeImputer
    from sklearn.linear_model import BayesianRidge

    imputer = IterativeImputer(estimator=BayesianRidge(), max_iter=10, random_state=0)
    filled_df = pd.DataFrame(imputer.fit_transform(df), columns=df.columns)

elif method == 3:
    # 回帰分析を使った補完（列ごとに処理）
    from sklearn.linear_model import LinearRegression
    import numpy as np

    filled_df = df.copy()
    for col in df.columns:
        if filled_df[col].isnull().any():
            train_data = filled_df[filled_df[col].notnull()]
            test_data = filled_df[filled_df[col].isnull()]
            X_train = train_data.drop(columns=[col])
            y_train = train_data[col]
            X_test = test_data.drop(columns=[col])

            # 特徴量がない場合（1列のみのデータ）はスキップ
            if X_train.shape[1] == 0:
                print(f"{col} の補完をスキップ（十分な特徴量がありません）")
                continue

            model = LinearRegression()
            model.fit(X_train, y_train)
            filled_df.loc[test_data.index, col] = model.predict(X_test)

else:
    print("無効な選択です。処理を終了します。")
    filled_df = df

# 5. 処理結果の確認
print("\n処理結果のプレビュー:")
print(filled_df.head())

# 6. 処理結果を保存してダウンロード
output_filename = "output_filled.csv"
filled_df.to_csv(output_filename, index=False)
print(f"\n処理結果を {output_filename} として保存しました。")
print("ダウンロードリンクを生成中...")
files.download(output_filename)

